{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\udd64 kele.el (Kubernetes Enablement Layer for Emacs)","text":"<p>Kele (k\u011b l\u00e8, or k\u0259-\u02c8l\u0259) (\u201cKubernetes Enablement Layer for Emacs\u201d) is a Kubernetes cluster management package. It empowers you to perform operations as coarse or fine-grained as you need, fast, and get back to your work.</p> <p>With Kele, you can:</p> <ul> <li>Manage contexts, e.g. switching, renaming, changing the default   namespace;</li> <li>Fetch and display the manifest of a single   resource;</li> <li>List collections of resources;</li> <li>Start and stop proxy servers;</li> <li>And more! </li> </ul> <p>See How-Tos &gt; Usage for more details on what\u2019s possible with Kele.</p> <p>Warning</p> <p>Kele is in very early stages of development. As of 2023/01/26, it is usable (I use it everyday for my day job!) but there are rough edges.</p> <p>Do give things a try and I\u2019d appreciate issues for any bugs or rough edges that you might come across.</p> <p>Thanks!</p> <p>\u2013 @jinnovation</p> <p></p> <p>Tip</p> <p>To learn more about how Kele compares to some other Kubernetes packages for Emacs, see: Explanations &gt; Comparisons with Similar Packages/Tools.</p> <p>Note</p> <p>Kele is not an official Kubernetes project.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Kele requires Emacs 28.1+.</p> <pre><code>(use-package kele\n:config\n(kele-mode 1)\n(bind-key (kbd \"s-k\") kele-command-map kele-mode-map))\n</code></pre>"},{"location":"#design-ethos","title":"Design Ethos","text":"<p>Kele aims to have PLANS. Namely, it aims to be:</p> <ul> <li>Performant: if it is easier/faster for you to simply use <code>kubectl</code> to get   the info you need instead of Kele, then Kele has failed;</li> <li>Lightweight: minimally intrusive, minimize context-switching, keep   \u201cembellishments\u201d to a minimum;</li> <li>Agile: get you the answers you need \u2013 and let you return to your other   work \u2013 as quickly as possible;</li> <li>Nimble: get you as coarse/detailed insight as needed at any given point,   with no compromise to any of the other tenets listed here;</li> <li>Smart: provide sensible defaults and interfaces that \u201cjust make sense\u201d.</li> </ul>"},{"location":"#about-the-name","title":"About the Name","text":"<p>The name Kele comes from the Mandarin term for cola, \u53ef\u4e50 (k\u011b l\u00e8). It is also an abbreviation of \u201cKubernetes Enablement Layer for Emacs.\u201d</p>"},{"location":"contributing/","title":"Contributor Guide","text":"<p>Info</p> <p>This page is a work-in-progress. More to come!</p> <p>Thanks for your interest in contributing to Kele! We\u2019re glad to have you. </p> <p>This page will give you all (well, most) of the information you\u2019ll need to get started.</p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Every symbol should be documented. This applies to both \u201cpublic\u201d (<code>kele-function-name</code>) and \u201cprivate\u201d (<code>kele--function-name</code>) symbols.</p> <p>Kele\u2019s documentation loosely follows the Diataxis framework.</p> <p>All new functionality should have corresponding user-facing documentation. Function docstrings are not a substitute for proper user-facing tutorials, usage instructions, etc.</p>"},{"location":"contributing/#changelog","title":"Changelog","text":"<p>We keep a changelog for Kele. Any change that is user-facing should be called out in the changelog.</p>"},{"location":"contributing/#architecture-decision-records-adrs","title":"Architecture Decision Records (ADRs)","text":"<p>We use architecture decision records (ADRs) in Kele very sparingly. Not every design decision made warrants an ADR of its own. As a contributor, you may be asked to write an ADR for your contribution, but only if it materially impacts Kele\u2019s user-facing behavior.</p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>We use Buttercup to write tests.</p> <p>All PRs should have corresponding unit/integration tests. I am far more likely to review and generally consider your PR if it has tests.</p>"},{"location":"explanations/comparisons/","title":"Comparisons with Similar Packages/Tools","text":"<p>This page compares Kele with some of its peer packages.</p> <p>Note</p> <p>Given Kele\u2019s relative infancy, this page compares less on concrete features and capabilities and more on design philosophy and overall goals. All packages listed here are, as of today, far more feature-complete than Kele.</p>"},{"location":"explanations/comparisons/#kubernetes-el","title":"kubernetes-el","text":"<p>kubernetes-el is a Kubernetes cluster management package for Emacs. It draws heavy inspiration from Magit, from its \u201cstatus page\u201d-centric interface design down to its prevalent use of Transient-based keybindings.</p> <p>Kele itself draws inspiration from kubernetes-el. In fact, the author of Kele is a co-maintainer of kubernetes-el.</p> <p>Kele draws from some lessons learned during kubernetes-el development and strives for a cluster management experience that has PLANS. Kele aims for a Kubernetes cluster management experience that is less intrusive, requires less context-switching, and is overall more performant than kubernetes-el. If Kele proves to be flexible enough that kubernetes-el could be re-implemented on top of Kele, then that\u2019s a sign that we\u2019ve done a good job here.</p> <p>More critically, however, one of <code>kubernetes-el</code>\u2018s biggest limitations is its lack of support for custom resources. Not only does this limitation impose a very low ceiling on the package\u2019s utility, the design decisions underpinning that limitation extend to <code>kubernetes-el</code>\u2018s incomplete support for the Kubernetes core API (see <code>kubernetes-el/kubernetes-el#306</code>. Overhauling the associated design decisions would amount, in my co-maintainer\u2019s opinion, to a complete rewrite of <code>kubernetes-el</code> \u2013 hence my decision to kick off development on Kele.</p>"},{"location":"explanations/comparisons/#kubel","title":"kubel","text":"<p>kubel is a similar \u201cUI-centric\u201d cluster management package to kubernetes-el. Its advantage over kubernetes-el is its accommodation of users with limited privilege/permissions within the clusters in question.</p> <p>Similar to kubernetes-el, Kele focuses on providing a cluster management experience that is more \u201cpiecemeal\u201d (\u201cget this targeted piece of information as quickly as possible and move on with your life\u201d) and requires less context-switching \u2013 unavoidable with a status-page-centric user interface \u2013 than kubel.</p>"},{"location":"explanations/design/","title":"Design","text":"<p>This page goes into some of the design particulars of Kele. As an end user, feel free to explore at your curiosity, but rest assured that none of the information here is strictly necessary for your successful use of Kele.</p> <p>Tip</p> <p>This page may at times contain forward-looking statements, e.g. of design details that are upcoming but have not yet made their way into the main branch.</p>"},{"location":"explanations/design/#caches","title":"Caches","text":"<p>Kele revolves around two main in-memory caches:</p> <ul> <li>One that maintains the <code>kubeconfig</code> contents (<code>kele--kubeconfig</code>);</li> <li>One that maintains the discovery cache in-memory (<code>kele--discovery-cache</code>).</li> </ul> <p>Both of these caches are populated asynchronously on <code>kele-mode</code> initialization.</p> <p>The kubeconfig cache is kept in sync via a file watcher, which allows Kele to only incur read costs when they\u2019re actually needed. This is particularly useful for the <code>kubeconfig</code> cache, since the Kubeconfig itself is only occasionally modified in response to discrete user events, such as switching context or the default namespace for a given context. In combination with asynchronous IO via the <code>async</code> package, Kele is able to keep itself in sync with the underlying Kube configurations and caches without deadlocking users\u2019 Emacs environment.</p> <p>On the other hand, the discovery cache is timer-based and pulls the contents of the discovery cache from the filesystem at a set interval, as dictated by <code>kele-discovery-refresh-interval</code>.</p> <p>Why?</p> <p>We elect not to use file-watchers for the discovery cache due to the risk of completely exhausting the file descriptors Emacs can use. For more details, see <code>adr-01</code>.</p>"},{"location":"how-tos/customization/","title":"Customization","text":"<p>This page outlines the customization options available to you in Kele.</p>"},{"location":"how-tos/customization/#keybindings","title":"Keybindings","text":""},{"location":"how-tos/customization/#defining-a-keybinding-prefix","title":"Defining a keybinding prefix","text":"<p>Kele comes with a spread of recommended keybindings predefined as part of <code>kele-command-map</code>. <code>kele-command-map</code> is not assigned to a keybinding by default, so as to be minimally disruptive to your personal configurations.</p> <p>Using <code>kele-command-map</code>, you can choose your own keybinding to act as the keybinding prefix for all of Kele\u2019s keybindings.</p> <p>To bind, say, <code>s-k</code> as the keybinding prefix:</p> <pre><code>(define-key kele-mode-map (kbd \"s-k\") 'kele-command-map)\n</code></pre> <p>Now you can use, for example, <code>s-k c</code> to access context-related commands. Give it a try!</p>"},{"location":"how-tos/customization/#interface","title":"Interface","text":""},{"location":"how-tos/customization/#resource-display","title":"Resource display","text":"<p>When displaying a single resource with <code>kele-get</code>, <code>kele-get</code> retrieves the full manifest for the requested resource. This may include \u201cnoisy\u201d sub-fields like <code>.metadata.managedFields</code> or the <code>kubectl.kubernetes.io/last-applied-configuration</code> annotation that distract from the \u201cimportant\u201d bits.</p> <p>You can routinely filter out such fields using the <code>kele-filtered-fields</code> custom variable. For example, to filter out both of the above:</p> <pre><code>(setq kele-filtered-fields\n'((metadata managedFields)\n(metadata annotations kubectl.kubernetes.io/last-applied-configuration)))\n</code></pre>"},{"location":"how-tos/customization/#suppress-keybinding-instructions","title":"Suppress keybinding instructions","text":"<p>The results buffer for <code>kele-get</code> prints out a header blurb outlining the keybindings available to you. If this is distracting to you or offends your minimalist tendencies, use <code>kele-get-show-instructions</code> to disable printing of the <code>kele-get</code> result buffer\u2019s keybindings.</p> <pre><code>(setq kele-get-show-instructions nil)\n</code></pre>"},{"location":"how-tos/customization/#customizing-cache-behavior","title":"Customizing cache behavior","text":"<p>Kele provides a handful of customization variables with which you can influence cache behavior.</p>"},{"location":"how-tos/customization/#change-the-discovery-cache-polling-interval","title":"Change the discovery cache polling interval","text":"<p>If you\u2019d like Kele to poll the discovery cache more or less frequently than the default, set <code>kele-discovery-refresh-interval</code>, then disable and re-enable <code>kele-mode</code>.</p> <pre><code>(setq kele-discovery-refresh-interval)\n(kele-mode -1)\n(kele-mode +1)\n</code></pre> Known Issue <p>There is a potential for Kele\u2019s copy of the discovery cache to have outdated (relative to clusters\u2019 \u201ctrue\u201d state) information, even immediately after a poll. This is due to Kele\u2019s polling interval being separate from <code>kubectl</code>\u2018s own default TTL for the discovery cache, which is 10 minutes \u201clazily\u201d (that is, the cache is invalidated and its contents re-pulled at the next <code>kubectl</code> invocation after 10 minutes).</p> <p>Given Kele\u2019s extensive usage of <code>kubectl</code> under the hood, this should rarely present an actual issue to you as a user. If it does, consider pegging the value of <code>kele-discovery-refresh-interval</code> to hover roughly around 10 minutes. The default value of <code>kele-discovery-refresh-interval</code> is 600 seconds, i.e. 10 minutes.</p>"},{"location":"how-tos/integrations/","title":"Integrations","text":"<p>Kele contains several integrations with select packages.</p>"},{"location":"how-tos/integrations/#awesome-tray","title":"awesome-tray","text":"<p><code>awesome-tray</code> \u201cfolds\u201d the modeline into the minibuffer for a compact UI.</p> <p>Kele ships with <code>awesome-tray</code> integration that will display the current context and namespace in your \u201cmodeline.\u201d</p> <p></p> <p>To enable, simply add <code>\"kele\"</code> to your desired place in <code>awesome-tray-active-modules</code>, like so:</p> <pre><code>(add-to-list 'awesome-tray-active-modules \"kele\" t)\n</code></pre>"},{"location":"how-tos/usage/","title":"Usage","text":"<p>Note</p> <p>You\u2019ll notice this page is pretty sparse. Kele is an early-stage package with lots of room to grow. Stay tuned for more!</p> <p>Note</p> <p>Kele doesn\u2019t have a default keybinding prefix for its commands. All examples documented here assume that you\u2019ve opted for <code>s-k</code>.</p> <p>For instructions on how to set your own keybinding prefix, see: How-Tos &gt; Customization.</p>"},{"location":"how-tos/usage/#dispatch","title":"Dispatch","text":"Keybinding Interactive function <code>s-k ?</code> <code>kele-dispatch</code> <p>Kele provides <code>kele-dispatch</code> as a launchpad for all subsequent Kele functionality. If you ever forget what the keybinding is for what you\u2019re trying to accomplish, reach for <code>kele-dispatch</code>.</p>"},{"location":"how-tos/usage/#working-with-resources","title":"Working with Resources","text":"<p>Interacting with resources in Kele centers around the <code>s-k r</code> prefix, which is bound to <code>kele-resource</code>.</p> <p><code>kele-resource</code> allows you to act on specific resource kinds. With <code>kele-resource</code>, you can, for example:</p> <ul> <li>Look up a given Kubernetes object by name, fetch its manifest, and display it   in a separate buffer;</li> <li>List out all resources of a given type.</li> </ul> <p><code>kele-resource</code> supports custom resources too!</p> <p><code>kele-resource</code> will first prompt you to select the kind that you\u2019d like to work with, after which you can choose to get a specific object of that kind by name. If the resource is namespaced, you will also be presented with the option to choose the namespace to select from.</p>"},{"location":"how-tos/usage/#getting-a-single-resource","title":"Getting a single resource","text":"<p>You can get a single resource of the given kind with: <pre><code>s-k r &lt;kind name&gt; g &lt;resource name&gt;`\n</code></pre></p> <p>This is bound to <code>kele-get</code>.</p> <p></p>"},{"location":"how-tos/usage/#listing-all-resources-of-a-single-kind","title":"Listing all resources of a single kind","text":"<p>You can list all resources of a single kind with: <pre><code>s-k r &lt;kind name&gt; l\n</code></pre></p> <p>This is bound to <code>kele-list</code>.</p> <p></p> <p>This will list all resources of the specified group-version and kind in a separate buffer in a table. From here, you can:</p> <ul> <li>Click any of the header columns to sort the list;</li> <li>Refresh the list with <code>g</code>;</li> <li>Click or hit <code>RET</code> on any of the entries to display its full manifest in a   separate buffer.</li> </ul>"},{"location":"how-tos/usage/#refreshing-a-resource","title":"Refreshing a resource","text":"<p>You can press <code>g</code> in a <code>kele-get</code> buffer to re-fetch and refresh the current resource.</p>"},{"location":"how-tos/usage/#contexts","title":"Contexts","text":"<p>Kele commands involving Kubernetes contexts center around the <code>s-k c</code> prefix (<code>kele-config</code>).</p> Keybinding Functionality Interactive function Demo <code>s-k c s</code> Switching from one context to another <code>kele-context-switch</code> <code>s-k c r</code> Renaming a context <code>kele-context-rename</code> <code>s-k c d</code> Deleting a context <code>kele-context-delete</code> <code>s-k c n</code> Changing the default namespace <code>kele-namespace-switch-for-current-context</code> <p>Tip</p> <p>Most context-related Kele functionality can also be done via Embark on any completion candidate in any context-related Kele command.</p>"},{"location":"how-tos/usage/#managing-proxy-servers","title":"Managing proxy servers","text":"<p>Kele allows for starting and stopping HTTP proxies for each context. The status of each context\u2019s proxy is displayed in the annotations for each cluster completion candidate.</p> Demo <p></p> <p>Note</p> <p>Any proxy server created via Kele is ephemeral; they are automatically closed and terminated after a set amount of time. For more details, see <code>kele-proxy-ttl</code>.</p> <p>Note</p> <p>Each context can only have one proxy server active at a time. This is an artificial limitation put in place by Kele.</p> Keybinding Functionality Interactive function <code>s-k p p</code> Start/stop proxy server process for the current context <code>kele-proxy-toggle</code> <code>s-k p P</code> Start/stop proxy server process for a specific context <code>kele-proxy-toggle</code>"},{"location":"references/","title":"References","text":"<p>This section contains technical descriptions of the inner workings and development of Kele. As a user, you will rarely if ever need to read these contents; you\u2019ll know if/when you do.</p>"},{"location":"references/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented here.</p> <p>The format is based on Keep a Changelog, and this project adheres to semantic versioning.</p>"},{"location":"references/changelog/#unreleased","title":"Unreleased","text":""},{"location":"references/changelog/#changed","title":"Changed","text":"<ul> <li>Bumped dependency <code>plz</code> from <code>0.3</code> to <code>0.4</code></li> </ul>"},{"location":"references/changelog/#041","title":"0.4.1","text":""},{"location":"references/changelog/#fixed","title":"Fixed","text":"<ul> <li>Fixed an issue where Kele can exhaust the number of file descriptors available for Emacs to use.</li> <li>Fixed an issue where command families that require proxy servers, e.g. <code>kele-resource</code>, result in false-positive   timeout errors when starting up the proxy server.</li> </ul>"},{"location":"references/changelog/#changed_1","title":"Changed","text":"<ul> <li>Discovery cache polling is now timer-based instead of \u201cdynamic,\u201d i.e. in response to filesystem changes.</li> </ul>"},{"location":"references/changelog/#040","title":"0.4.0","text":"<p>Lots of fun stuff in this release.</p> <p>Most importantly, Kele 0.4.0 introduces <code>kele-list</code> (<code>s-k &lt;resource type&gt; l</code>) and \u2013 with it \u2013 the ability to list all resources of a given type in tabulated form. Before, you could only fetch single resources. Now, with <code>kele-list</code>, you can create ad-hoc \u201coverviews\u201d of specific resource types within a given context and namespace; hitting Enter on any entry in this list brings up the resource\u2019s full manifest.</p> <p>Kele 0.4.0 also introduces the <code>kele-proxy</code> command palette (<code>s-k p</code>) for starting/stopping proxy servers for contexts. It also fleshes out the Kubeconfig management command palette (<code>s-k c</code>).</p> <p>For more details, see: How-Tos &gt; Usage.</p>"},{"location":"references/changelog/#added","title":"Added","text":"<ul> <li>Added a <code>kele-proxy</code> command prefix for managing proxy servers</li> <li>Added a keybinding to <code>kele-context</code> to enable/disable the proxy server for   the current context</li> <li>Added a keybinding to <code>kele-context</code> for deleting a context</li> <li>Added a keybinding to open <code>kele-kubeconfig-path</code> in a buffer</li> <li>Added a keybinding to <code>kele-resource</code> to support listing out all resources of   a given type (<code>kele-list</code>)</li> </ul>"},{"location":"references/changelog/#fixed_1","title":"Fixed","text":"<ul> <li><code>kele-context</code> and <code>kele-resource</code> now wait on kubeconfig sync completion to   finish if one is currently in progress</li> <li>Fixed a bug where force-enabling or force-disabling <code>kele-mode</code> (via either   <code>(kele-mode 1)</code> or <code>(kele-mode -1)</code>) when <code>kele-mode</code> is already active or   inactive (respectively) resulted in errors</li> <li>Fixed an issue where attempting to invoke <code>s-k &lt;resource name&gt; g</code> sometimes   results in the following error: <code>transient-setup: Suffix   transient:kele-resource::command is not defined or autoloaded as a command</code></li> </ul>"},{"location":"references/changelog/#changed_2","title":"Changed","text":"<ul> <li>Renamed <code>kele-context</code> to <code>kele-config</code></li> <li>Increased the default value of <code>kele-proxy-ttl</code> from <code>60</code> to <code>180</code></li> <li>Binding for <code>kele-get</code> in <code>kele-get-mode</code> changed from <code>U</code> to <code>g</code></li> </ul>"},{"location":"references/changelog/#030","title":"0.3.0","text":"<p>This release focuses on providing Kele\u2019s command palette and user interface with a scalable foundation for future growth. As Kele\u2019s spread of user-facing commands grows, it becomes less and less reasonable to expect users to <code>M-x</code> everything.</p> <p>To that end, this release adds the following:</p> <ul> <li>A Kele command keymap that will allow keybinding-based access to all   Kele-based functionality (see How-Tos &gt; Customization and How-Tos &gt; Usage   for more details)</li> <li>A spread of three Transient-based \u201cprefix\u201d commands \u2013 <code>kele-context</code>,   <code>kele-resource</code>, and <code>kele-dispatch</code> \u2013 for nested command discovery and   ad-hoc configuration, e.g. overriding the context and namespace to use for   resource fetching. Again, see How-Tos &gt; Usage for more details.</li> </ul> <p>I\u2019m optimistic that these two additions make Kele\u2019s user interface much more pleasant and nimble, while also giving it ample room to grow in complexity and scope in the coming releases.</p>"},{"location":"references/changelog/#added_1","title":"Added","text":"<ul> <li><code>kele-get</code> resource name input now supports completion! </li> <li><code>kele-get</code> buffers now have keybindings for quitting and killing the resource   display buffer</li> <li>You can now press <code>U</code> in <code>kele-get</code> buffers to re-fetch and refresh the   current resource</li> <li><code>kele-get</code> buffers\u2019 front matter now outlines the available keybindings</li> <li>Added a <code>kele-dispatch</code> command for when you forget the specific keybinding of   what you\u2019re trying to accomplish</li> <li>Added a <code>kele-context</code> command prefix for context-related actions</li> <li>Added a <code>kele-resources</code> command prefix for acting on specific resource kinds,   e.g. <code>get</code>ting, with support for selecting the context, namespace, and the   group-version to use (in cases of ambiguity)</li> </ul>"},{"location":"references/changelog/#changed_3","title":"Changed","text":"<ul> <li>Added dependency: <code>s</code></li> <li>Removed dependency: <code>requests</code></li> <li>Increased minimum required Emacs version to 28.1</li> </ul>"},{"location":"references/changelog/#021","title":"0.2.1","text":"<p>This release focuses on refining the <code>kele-get</code> experience \u2013 usability improvements and general bugfixes.</p>"},{"location":"references/changelog/#added_2","title":"Added","text":"<ul> <li><code>kele-get</code> buffers now have a dedicated minor mode, <code>kele-get-mode</code>.</li> <li><code>kele-get</code> buffers now print a header detailing, for the resource under   display: the context it was fetched from; and the time of retrieval</li> <li>Added a custom variable <code>kele-filtered-fields</code> with which you can routinely   filter out resource fields from display in <code>kele-get</code></li> </ul>"},{"location":"references/changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fixed an issue where <code>kele-get</code> results buffer incorrectly prints namespace   for un-namespaced resources as <code>nil</code></li> <li>Fixed an issue where <code>kele-get</code> refused to display the retrieved resource, if   a buffer corresponding to that resource already exists</li> </ul>"},{"location":"references/changelog/#changed_4","title":"Changed","text":"<ul> <li><code>kele-get</code> completion for the resource type now only returns resources that   support the <code>get</code> verb</li> </ul>"},{"location":"references/changelog/#020","title":"0.2.0","text":"<p>This release introduces <code>kele-get</code> \u2013 <code>kubectl get</code>, the Emacs way . With <code>kele-get</code> you can interactively specify the kind and name of the resource that you\u2019d like to <code>get</code> and display its manifest in a separate buffer. What\u2019s more, it supports custom resources right out the gate \u2013 a long-standing functionality gap in <code>kubernetes-el</code>.</p> <p>See How-Tos &gt; Usage &gt; Working with Resources for details and a demo GIF. It\u2019s very much an MVP so there are some rough edges. Please open an issue for any peculiar behavior that you notice.</p>"},{"location":"references/changelog/#added_3","title":"Added","text":"<ul> <li>Implemented <code>kele-get</code> for interactively getting and displaying a given   resource</li> <li>Context annotations now display whether a proxy server is currently active for   the given context</li> <li>Implemented interactive functions for per-context proxy server management:   <code>kele-proxy-start</code>, <code>kele-proxy-stop</code>, and <code>kele-proxy-toggle</code></li> </ul>"},{"location":"references/changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Fixed an issue where disabling <code>kele-mode</code> resulted in an error reporting   unbound slot <code>filewatch-id</code> on <code>kele--discovery-cache</code></li> <li>Fixed an issue where cluster servers with ports,   e.g. <code>https://127.0.0.1:51134</code>, were not recognized properly</li> <li>Fixed an issue where namespace completion candidates failed to populate on   initial fetch of said namespaces from the Kubernetes API</li> </ul>"},{"location":"references/changelog/#changed_5","title":"Changed","text":"<ul> <li>Buffer for contexts\u2019 proxy processes are now hidden</li> <li>Default value for <code>kele-cache-dir</code> is now <code>~/.kube/cache</code>; before it was   relative to the value of <code>kele-kubeconfig-path</code> (and unreliably so)</li> </ul>"},{"location":"references/changelog/#011","title":"0.1.1","text":""},{"location":"references/changelog/#added_4","title":"Added","text":"<ul> <li>Kubeconfig file watching is now asynchronous and therefore non-blocking!</li> <li>Kubeconfig file watching now prints a progress report denoting when changes   were detected (and thus reading has begun asynchronously) and when reading has   completed</li> </ul>"},{"location":"references/changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Fixed an issue where proxies were being created for the current context,   regardless of which context it was actually requested for</li> <li>Fixed an issue in <code>kele-namespace-switch-for-context</code> where the selection   candidates were pulled for the current context rather than the argument   context</li> <li>Fixed an issue where attempting to pull completion candidates via queries to   the proxy API server resulted in an error, as well as multiple proxy server   processes being inadvertently spun up for the same context</li> <li>Fixed an issue where custom kubeconfig path is not respected by <code>kubectl</code>   invocations</li> </ul>"},{"location":"references/changelog/#changed_6","title":"Changed","text":"<ul> <li>Added dependency: <code>plz</code></li> <li>Added dependency: <code>async</code></li> </ul>"},{"location":"references/changelog/#010","title":"0.1.0","text":"<p>Kele is born!</p> <p>This initial release of Kele has a very simple goal: \u201c<code>kubectx</code> and <code>kubens</code>, but make it Emacs.\u201d Its feature set is limited but lays the foundation \u2013 both in terms of implementation and \u201cdesign philosophy\u201d \u2013 for future enhancements.</p>"},{"location":"references/changelog/#added_5","title":"Added","text":"<ul> <li>Added ability to switch and rename contexts, with completion and caching</li> <li>Added ability to switch namespaces for any given context</li> </ul>"},{"location":"references/adrs/","title":"Architecture Decision Records (ADRs)","text":"<p>This section collects \u201carchitecture decision records (ADRs)\u201d for Kele. These are records of \u201carchitecturally significant\u201d decisions, that materially impact Kele\u2019s design and capabilities.</p> <p>Tip</p> <p>For more information about ADRs, see Michael Nygard\u2019s seminal post \u201cDocumenting Architecture Decisions\u201d.</p>"},{"location":"references/adrs/00-template/","title":"ADR 0000: [title]","text":""},{"location":"references/adrs/00-template/#status","title":"Status","text":""},{"location":"references/adrs/00-template/#context","title":"Context","text":""},{"location":"references/adrs/00-template/#decision","title":"Decision","text":""},{"location":"references/adrs/00-template/#consequences","title":"Consequences","text":""},{"location":"references/adrs/01-timer-based-discovery-cache/","title":"adr-01: Timer-based discovery-cache caching","text":""},{"location":"references/adrs/01-timer-based-discovery-cache/#status","title":"Status","text":"<p>Implemented in #150.</p>"},{"location":"references/adrs/01-timer-based-discovery-cache/#context","title":"Context","text":"<p>As of 2023-03-05, Kele uses a naive set of two separate caches:</p> <ul> <li>The \u201ckubeconfig cache,\u201d which brokers reads from the user\u2019s configured kubeconfig (<code>kele-kubeconfig-path</code>);</li> <li>The \u201cdiscovery cache,\u201d which brokers reads from the user\u2019s discovery cache.</li> </ul> <p>Note</p> <p>The latter, confusingly, shares the same name with the discovery cache that lives in the user\u2019s filesystem, typically under <code>~/.kube/cache/discovery</code>. We use \u201cdiscovery cache\u201d to refer specifically to the Kele data structure, and use \u201cfilesystem discovery cache\u201d to refer to the \u201cactual\u201d discovery cache.</p> <p>On enablement of <code>kele-mode</code>, Kele initializes both the kubeconfig cache and the discovery cache. The kubeconfig cache loads the contents of the user\u2019s <code>kubeconfig</code> file into memory; likewise, the discovery cache loads the contents of the user\u2019s filesystem discovery cache into memory. Both caches initialize [file watchers] that \u201cauto-refresh\u201d the respective cache contents on changes to the underlying file(s).</p> <p>The combined use of these two caches enables near-instant completion of:</p> <ul> <li>A user\u2019s contexts and other cluster configurations;</li> <li>The available API groups, versions, and kinds on a given cluster.</li> </ul>"},{"location":"references/adrs/01-timer-based-discovery-cache/#problems","title":"Problems","text":"<p>The aforementioned \u201call-at-once\u201d approach has proven to have several shortcomings.</p>"},{"location":"references/adrs/01-timer-based-discovery-cache/#gratuitous-file-watching","title":"Gratuitous File-Watching","text":"<p>The most fundamental problem is that the discovery cache does not scale. Emacs file-watching uses file descriptors under the hood, which Emacs has a [finite number available for use at any given time][1]. Exceeding this limit results in an error to the following effect:</p> <pre><code>File watching not possible, no file descriptor left: 975\n</code></pre> <p>This limit is, to my knowledge, not user-configurable. Even if it were, it is an unreasonably invasive thing to ask users to do \u2013 for an Emacs package of all things. Most notably, this limit is, like all things, shared globally within Emacs, e.g. by [LSP-Mode][lsp-mode] and [auto-revert-mode], making the \u201creal\u201d limit for Kele much lower. In order to be a \u201cgood Emacs citizen,\u201d Kele needs to be much more conservative and strategic in its use of file-watchers.</p> <p>We note that it is very easy to hit this limit. Anecdotally, I maintain kubectl access to a handful of production-scale clusters as part of my day job, and simply adding a couple more ad-hoc [Kind] clusters as part of integration-testing for this very package is enough for me to hit the limit. Doing so requires me to manually delete the filesystem discovery cache directories corresponding to these transient Kind clusters On top of being annoying, this is also a fundamentally unreasonable workaround; what happens if a user simply has that many clusters to maintain?</p>"},{"location":"references/adrs/01-timer-based-discovery-cache/#decision","title":"Decision","text":"<p>The simplest and \u201cstupidest\u201d solution to this problem is to make caching of the filesystem discovery cache timer-based rather than filewatch-based.</p>"},{"location":"references/adrs/01-timer-based-discovery-cache/#consequences","title":"Consequences","text":"<p>This approach represents, to an extent, a \u201cregression\u201d of sorts in the functionality of the discovery cache, as now the contents thereof are not guaranteed to be fully up-to-date with those of the filesystem dicovery cache. We decide that this is safe, as the set of group-version-kinds present in a cluster are unlikely to change that frequently. This is consistent with <code>kubectl</code>\u2018s own refresh policy for the filesystem discovery cache, which refills the cache every ten minutes \u2013 and lazily, at that, i.e. on the next user invocation of <code>kubectl</code> after the ten-minute mark.</p>"}]}